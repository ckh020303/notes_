# 代码移植思路（c02lite-at32->stm32）
## 产品功能概述
C02是一款车载解码器，可以根据用户需求对特定车型CAN数据ID进行捕获，并实现其他功能，如在车屏上加装倒车影像和360全景，低成本实现低配版达到顶配版配置。
### 具体功能表述
- FDCAN：实现汽车CAN数据捕获和转发（CAN1接收、CAN2发送）
  - callback函数：接收CAN数据，反转红灯电平，清空TIM计数
- USART：串口打印（调试使用）
- LED
  - LED_RED：
    - 初始化开始，红灯常亮；初始化结束，红灯熄灭；
    - 红灯快速闪烁：正在接收CAN数据；
    - 红灯熄灭：没有接收到CAN数据，即将进入睡眠模式（go-to-sleep mode）
  - LED_GREED：
    - 绿灯常亮：开启转发，开启继电器；
    - 绿灯熄灭：关闭继电器
- GPIO-SWITCH
  - SW1\SW2\SW3：读取拨码，选择车型
  - SW4：选择模式（是否开启转发）
- TIMER
  - TIM2：200ms，常亮红灯
  - TIM3：4000ms，进入睡眠模式
- IWDG
- FLASH：存储使用状态，在下次上电时可以读取状态，开启或者关闭转发
- TJA1043：CAN收发器，实现正常模式和睡眠模式
- RELAY：继电器开关，开启则进行转发操作，关闭则相当于直连两路CAN，不进行转发

## 功能实现过程
- 接收数据
- 进入中断、进入回调函数
- 将数据添加到RingBuffer
- 在while循环里，一直读RingBuffer里面的数据
- 读取到数据之后，进入到Forwarder
- 读取按键ID状态和速度ID状态
- 如果速度大于0，则开启继电器，开启转发功能
- 过滤特定的速度ID数据
- 将接收数据包里面的值等效赋值给发送数据包
- 切换CAN口进行转发

## 移植过程
- 查看原理图、列出IO口
- 进行图形化配置
- 学习C/C++混合编译
- 实现基础功能（FDCAN收发，USART串口输出打印）
- 初步移植代码框架
- 移植RingBuffer、创建BufferHandle文件（缓冲区处理）
- 实现CAN正常模式
- 实现转发功能（从CAN1接收数据存入RingBuffer，CAN2再从RingBuffer读取数据并发送）
- 再次移植代码框架
- 实现特定ID数据过滤
- 实现定时器功能、完善代码
- 实现看门狗、CAN监听模式
- 实现FLASH擦除写入，按键功能以及根据车型设定波特率
- 添加测试车型
- 更新睡眠模式

## 注意事项
- C和C++混合编译问题解决方法
```C++
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif

// 在CPP函数内调用类函数，再在C函数内调用该函数
```
- 使用不了FDCAN，不进入中断和回调函数
  - 发现没有配置TJA1043的正常模式
  - 没有使能FDCAN中断
- 开启定时器时，进入一次中断，且重置计数值无用
```C++
void Timer_Reload(TIM_HandleTypeDef htim)
{
	__HAL_TIM_SET_COUNTER(&htim,0);
}

void Timer_Start(TIM_HandleTypeDef htim)
{
	__HAL_TIM_CLEAR_FLAG(&htim, TIM_FLAG_UPDATE);
	HAL_TIM_Base_Start_IT(&htim);
}
// 开启定时器中断前要清除标志位
// 先重置再开启
```
- CAN转发不成功，数据错误，出现远程帧
  - 发送结构体没有全部赋值，导致错误
- FLASH擦除写入不成功
  - FLASH_EraseInitTypeDef结构体使用错误，是对应第几页不是对应地址
  - 把地址转换为第几页/扇区
    ```C++
    #define FLASH_MAX_SIZE 0x1FFFF
    #define PAGE_SIZE   FLASH_PAGE_SIZE          /* 2KB Page */
    #define PAGE_TOUCH  (0x08000000 + FLASH_MAX_SIZE - PAGE_SIZE * 2 + 1)
    #define PAGE_NB		((PAGE_TOUCH - 0x08000000) / PAGE_SIZE)
    ```
  - 清除标志位
    ```C++
    #define FLASH_FLAG_ALL_ERRORS           (FLASH_FLAG_OPERR   | FLASH_FLAG_PROGERR | FLASH_FLAG_WRPERR | \
                                         FLASH_FLAG_PGAERR  | FLASH_FLAG_SIZERR  | FLASH_FLAG_PGSERR | \
                                         FLASH_FLAG_MISERR  | FLASH_FLAG_FASTERR | \
                                         FLASH_FLAG_OPTVERR | FLASH_FLAG_ECCC    | FLASH_FLAG_ECCD)

    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
    ```
- 看门狗老是复位
  - 初始化过长来不及喂狗，可以在初始化快结束时再初始化看门狗
- 睡眠模式错误，老是唤醒不了，卡住
  - 不能通过中断读取引脚电平边沿变化，而是必须通过轮询的方式读取ERR引脚电平为低时，判断为有CAN报文唤醒
    ```C++
      enterGotoSleepCommandMode();
      delay_ms(10);

      while(1)
      {
        if(!getValue(FDCAN1_ERR_GPIO_Port,FDCAN1_ERR_Pin)){
          printf("Wake up!\n");
          enterNormalMode();
          break;
        }
        delay_ms(10);
      }
    ```
- FD mode with BRS设置失败，发送不了大于1M 速率的数据
  - 需要配置TDC发送延时补偿
    ```c++
    /* Configure and enable Tx Delay Compensation, required for BRS mode.
	     TdcOffset default recommended value: DataTimeSeg1 * DataPrescaler
	     TdcFilter default recommended value: 0 */
	if (HAL_FDCAN_ConfigTxDelayCompensation(&hfdcan, hfdcan.Init.DataPrescaler * hfdcan.Init.DataTimeSeg1, 0) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_FDCAN_EnableTxDelayCompensation(&hfdcan) != HAL_OK)
	{
		Error_Handler();
	}
    ``
  - 采样点有要求(Seg1 + 1 / Seg1 + 1 + Seg2)： 70%~90%